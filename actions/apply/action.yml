---
# This action requires that AWS/Azure/Gcloud credentials are setup
# AWS: https://github.com/aws-actions/configure-aws-credentials?tab=readme-ov-file#long-term-credentials-warning-10323
name: 'Apply'
description: 'Provision Terraform resources'
inputs:
  project-path:
    description: "Project path"
    required: true
  plan-filename:
    description: "Terraform plan filename"
    required: false
    default: "plan.out"
  cloud-service-provider:
    description: 'Cloud service provider'
    required: false
    default: aws
  backend-configs:
    description: 'List of backend configuration options for terraform init. Expects a series of key-value pairs or a single file when remote state is not `local`. Make sure to mask sensitive values.'
    required: false
    default: '[]'
  force_service_machines:
    description: 'Append an ssh port rule for all machines'
    required: false
    default: 'true'
  force_service_biganimal:
    description: 'Append service cidr blocks to BigAnimals allow list'
    required: false
    default: 'true'
  service_cidrblocks:
    description: 'Service CIDR blocks which will be applied when defaults=service under a port configuration'
    required: false
    default: '[]'
  force_dynamic_ip:
    description: 'Append the controllers ip to the service cidr blocks.'
    required: false
    default: 'true'
  mask_secrets:
    description: 'Mask secrets from terraform output'
    required: false
    default: 'true'
runs:
  using: "composite"
  steps:
    - name: Check dependencies
      shell: bash
      run: |
        programs=("terraform" "edb-terraform" "aws" "jq")

        for program in "${programs[@]}"
        do
          if ! builtin type -P "$program" >/dev/null 2>&1
          then
            printf "$program not found" >&2
            exit 1
          fi
        done

    - name: Check if csp credentials configured
      shell: bash
      env:
        CLOUD_SERVICE_PROVIDER: ${{ inputs.cloud-service-provider }}
      run: |
        case "$CLOUD_SERVICE_PROVIDER" in
          aws)
            aws sts get-caller-identity
            ;;
          *)
            printf "Cloud service provider not supported: $CLOUD_SERVICE_PROVIDER" 1>&2
            exit 1
            ;;
        esac

    - name: Terraform init
      working-directory: ${{ inputs.project-path }}
      shell: bash
      env:
        BACKEND_CONFIGS: ${{ inputs.backend-configs }}
      run: |
        CONFIGS=$(echo $BACKEND_CONFIGS | jq -r .[])
        OPTION="-backend-config="
        CONFIG_STR=("-input=false")
        for config in $CONFIGS
        do
          CONFIG_STR+=("$OPTION$config")
        done

        terraform init "${CONFIG_STR[@]}"

    - name: Terraform plan
      working-directory: ${{ inputs.project-path }}
      shell: bash
      env:
        PLAN_FILENAME: ${{ inputs.plan-filename }}
        FORCE_SERVICE_MACHINES: ${{ inputs.force_service_machines }}
        FORCE_SERVICE_BIGANIMAL: ${{ inputs.force_service_biganimal }}
        SERVICE_CIDRBLOCKS: ${{ inputs.service_cidrblocks }}
        FORCE_DYNAMIC_IP: ${{ inputs.force_dynamic_ip }}
      run: |
        terraform plan -input=false \
                       -out="$PLAN_FILENAME" \
                       -var "force_service_machines=$FORCE_SERVICE_MACHINES" \
                       -var "force_service_biganimal=$FORCE_SERVICE_BIGANIMAL" \
                       -var "service_cidrblocks=$SERVICE_CIDRBLOCKS" \
                       -var "force_dynamic_ip=$FORCE_DYNAMIC_IP"

    - name: Terraform apply
      working-directory: ${{ inputs.project-path }}
      shell: bash
      env:
        PLAN_FILENAME: ${{ inputs.plan-filename }}
      run: |
        terraform apply -input=false \
                        -auto-approve \
                        "$PLAN_FILENAME"

    - name: Mask secrets
      working-directory: ${{ inputs.project-path }}
      shell: bash
      if: ${{ inputs.mask_secrets == true || inputs.mask_secrets == 'true' }}
      run: |
        MASK_PREFIX="::add-mask::"
        SECRET_KEYS='["password","public_ip","public_dns"]'

        # Muli-line secrets must be escaped or applied per-line.
        # https://github.com/actions/toolkit/blob/main/docs/commands.md#register-a-secret
        # - multiline secret failed to mask so we fallback to manual masking
        for line in $(cat ssh-id_rsa)
        do
          echo "$MASK_PREFIX$line"
        done

        # mask secrets from a list of keynames
        SECRETS=$( \
          terraform output -json servers \
          | jq -r 'paths(scalars) as $path | {key: $path[-1], value: getpath($path)}' \
          | jq -r --argjson secret_keys "$SECRET_KEYS" \
            'select(.key as $key | $secret_keys | index($key))' \
          | jq -r '"\(.value)"'
        )

        for secret in $SECRETS
        do
          echo "$MASK_PREFIX$secret"
        done
